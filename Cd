WITH process_durations AS (
    SELECT
        p.task_id,
        t.hash,
        p.start_dt,
        p.end_dt,
        TIMESTAMPDIFF(SECOND, p.start_dt, p.end_dt) AS duration
    FROM processes p
    JOIN tasks t ON p.task_id = t.id
),
with_process_ids AS (
    SELECT
        *,
        ROW_NUMBER() OVER (PARTITION BY task_id ORDER BY start_dt, end_dt) AS proc_id
    FROM process_durations
),
parallel_check AS (
    SELECT
        a.task_id,
        a.hash,
        a.proc_id,
        a.start_dt,
        a.end_dt,
        a.duration,
        CASE
            WHEN EXISTS (
                SELECT 1
                FROM with_process_ids b
                WHERE a.task_id = b.task_id
                  AND a.proc_id != b.proc_id
                  AND a.start_dt < b.end_dt
                  AND b.start_dt < a.end_dt
            ) THEN 1 ELSE 0
        END AS is_parallel
    FROM with_process_ids a
),
final_aggregates AS (
    SELECT
        hash,
        COUNT(*) AS processes,
        SUM(is_parallel) AS total_parallel_processes,
        SUM(duration) AS total_usage_time,
        ROUND(SUM(
            CASE WHEN is_parallel = 1 THEN duration * 0.02 ELSE duration * 0.01 END
        ), 2) AS total_cost
    FROM parallel_check
    GROUP BY hash
)
SELECT *
FROM final_aggregates
ORDER BY hash;
